<!DOCTYPE html>
<html lang="en">
    <head>
        <title></title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <script type="module" src="./src/deck.mjs"></script>
        <style> 
            body { padding:0; margin:0;} 
            razzle-slide { opacity:0 }
        </style>
    </head>
    <body>
        <razzle-deck>
            <razzle-slide>
                <h1>Outcome Logic</h1>
                <blockquote>
                    <p> a novel generalization of Hoare Logic that is both monadic (to capture computational effects) and monoidal (to reason about outcomes and reachability).
                    </p>
                    <p>OL expresses true positive bugs, while retaining correctness reasoning abilities as well.</p>
                </blockquote>
            </razzle-slide>
            <razzle-slide>
                <h3>Motivating example: non-determinism</h3>
                <p>If \(Î£\) are some states, \(âŸ¦CâŸ§:Î£â†’ ğ’«(Î£)\) is the action of the non-deterministic program \(C\) on those states, and \(Ïƒ,Ï„ : Î£\) and \(P,QâŠ†Î£\) then:
                <dl>
                    <dt>Hoare Logic:</dt>
                    <dd style="padding-top:1em">\(âŠ¨ \{P\}C\{Q\}\) 
                        <span style="padding-left:1em;padding-right:1em;">iff</span>
                        \(âˆ€ÏƒâˆˆP, âˆ€Ï„âˆˆ âŸ¦CâŸ§(Ïƒ), Ï„ âˆˆ Q\)
                    </dd>
                    <dt style="padding-top:1em">Incorrectness Logic:</dt>
                    <dd style="padding-top:1em">\(âŠ¨ [P]C[Q]\) 
                        <span style="padding-left:1em;padding-right:1em;">iff</span>
                        \(âˆ€Ï„âˆˆQ, âˆƒÏƒ âˆˆ P, Ï„ âˆˆ âŸ¦CâŸ§(Ïƒ)\)
                    </dd>
                </dl>
            </razzle-slide>
            <razzle-slide>
               <h3>Hoare Logic:</h3>
               <svg viewBox="0 0 400 250">
                   <path d="M50 50 V 200" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="20" y="105">\(P\)</foreignObject>
                   <path d="M300 10 V 250" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="310" y="105">\(Q\)</foreignObject>
                   <path d="M275 50 V 200" stroke-dasharray="5" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="150" y="105">\(âŸ¦CâŸ§^\dagger(P)\)</foreignObject>
                   <path d="M50 50 L255 50" stroke-dasharray="5" stroke="black" stroke-width="1" fill="none" marker-end="url(#arrowhead)"/>
                   <path d="M50 200 L255 200" stroke-dasharray="5" stroke="black" stroke-width="1" fill="none"marker-end="url(#arrowhead)"/>
               </svg>
               <p>Postcondition \(Q\) â€œover-approximatesâ€ \(âŸ¦CâŸ§^\dagger(P)\), it's allowed to include some unreachable outcomes.</p> 
            </razzle-slide>
            <razzle-slide>
               <h3>Incorrectness Logic:</h3>
               <svg viewBox="0 0 400 250" >
                   <path d="M50 50 V 200" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="20" y="105">\(P\)</foreignObject>
                   <path d="M300 50 V 200" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="310" y="105">\(Q\)</foreignObject>
                   <path d="M275 10 V 250" stroke-dasharray="5" stroke="black" stroke-width="3" fill="none" />
                   <foreignObject x="150" y="105">\(âŸ¦CâŸ§^\dagger(P)\)</foreignObject>
                   <path d="M50 50 L255 10" stroke-dasharray="5" stroke="black" stroke-width="1" fill="none" marker-end="url(#arrowhead)"/>
                   <path d="M50 200 L255 240" stroke-dasharray="5" stroke="black" stroke-width="1" fill="none"marker-end="url(#arrowhead)"/>
               </svg>
               <p>Postcondition â€œunder-approximatesâ€ \(âŸ¦CâŸ§^\dagger(P)\), it's allowed to leave out some reachable outcomes</p>
            </razzle-slide>
            <razzle-slide>
                <p>Both HL and IL combine two difference sources of outcome multiplicity:</p>
                <ul>
                    <li>Number of states in the precondition</li>
                    <li>Nondeterministic branching</li>
                </ul><p>
                As a result, some kinds of incorrectness and incorrectness are hard to describe</p>
            </razzle-slide>
            <razzle-slide>
                <p>Heisenbugs: â€œEvery state in the precondition can (sometimes, nondeterministically) produce an errorâ€</p>
                <p>Correct Shuffles: â€œEach of several postconditions is (sometimes, nondeterministically) reachable from every state in the preconditionâ€</p>
                <p>Manifest Errors (Le et al.): â€œExecuting \(C\) on any state terminates erroniously in some state satisfyingâ€¦â€</p>
            </razzle-slide>
            <razzle-slide>
                <h3>Idea for a solution:</h3>
                <p>look at properties of the sets \(âŸ¦CâŸ§(x)\) for \(xâˆˆ P\), or actually more generally, \(âŸ¦CâŸ§^\dagger(X)\) for \(X \subseteq P\).</p>
                <p>A Heisenbug means that \(âŸ¦CâŸ§^\dagger(X)\) overlaps error, for any choice of \(X\subseteq P\).<p>
                <p>A fair shuffle means that \(âŸ¦CâŸ§^\dagger(X)\) covers your shuffle outcomes, for any choice of \(X\subseteq P\).</p>
            </razzle-slide>
            <razzle-slide>
                <dl>
                    <dt>Generic Outcome Logic:</dt>
                    <dd style="padding-top:1em">\(âŠ¨ âŸ¨Ï†âŸ©CâŸ¨ÏˆâŸ©\) 
                        <span style="padding-left:1em;padding-right:1em;">iff</span>
                        \(âˆ€SâŠ¨Ï†,\qquad âŸ¦CâŸ§^\dagger(S) âŠ¨ Ïˆ\)
                    </dd>
                </dl>
                <p>Because we're interested in properties of
                \(âŸ¦CâŸ§^\dagger(X)\), we need to promote \(âŠ¨\)
                from a relation between states and assertions to a relation
                between <em>sets of states</em> and assertions.</p>
            </razzle-slide>
            <razzle-slide>
                <p>To do this (and get the nondeterministic outcome logic from the paper) we supply:</p>
                <ol>
                    <li>An execution model: basically \(ğ’«,âˆª,\varnothing\) (details postponed).</li> 
                    <li>Atomic commands \(Î£â†’ğ’«(Î£)\).</li>
                    <li>Atomic assertions \(\mathsf{Prop}\), and an
                        atomic satisfaction relation, in this case:<br>
                        \(S âŠ¨ p\) iff \(S â‰  \varnothing\) and \(âˆ€ÏƒâˆˆS, Ïƒ âˆˆ v(p)\).
                    </li>
                </ol>
            </razzle-slide>
            <razzle-slide>
                Given our atomic assertions, we build an assertion language as follows:
                </p>
                \(Ï†::= âŠ¤ \mid âŠ¥ \mid Ï†âˆ§Ïˆ \mid Ï†â‡’Ïˆ \mid Ï†\oplus Ïˆ \mid âŠ¤^\oplus\mid p\)
                <p>and we extend satisfaction (skipping classical connectives \(âŠ¤,âŠ¥,âˆ§, â‡’\)):</p>
                <table> <tr>
                    <td>\(S âŠ¨ Ï†\oplusÏˆ\)</td><td style="padding:0 1em 0 1em"> iff </td><td>\( S=TâˆªR\) where \(T âŠ¨ Ï†, R âŠ¨ Ïˆ\)</td>
                </tr><tr>
                    <td>\(S âŠ¨ âŠ¤^\oplus\)</td><td style="padding:0 1em 0 1em"> iff </td><td>\( S=\varnothing\)</td>
                </tr><tr>
                </tr>
                </table>
            </razzle-slide>
            <razzle-slide>
                <p>Observe:</p>
            </razzle-slide>
            <razzle-slide>
                    \(S âŠ¨ Ï†\oplus âŠ¤^\oplus\) just in case \(S âŠ¨ Ï†\).
            </razzle-slide>
            <razzle-slide>
                \(âŸ¨QâŸ©CâŸ¨âŠ¤^\oplusâŸ©\) just in case \(âŸ¦CâŸ§^\dagger(Q) = \varnothing\)
            </razzle-slide>
            <razzle-slide>
                \(âŸ¨Ï†âŸ©CâŸ¨âŠ¥âŸ©\) just in case \(âˆ€S, S\nvDash Ï† \)
            </razzle-slide>
            <razzle-slide>
                <p> \(âŸ¨Ï†âŸ©CâŸ¨Ïˆâˆ¨âŠ¤^\oplusâŸ©\) expresses partial
                correctness. </p>
                <p>Holds just in case given a set of states
                satisfying \(Ï†\), \(âŸ¦CâŸ§^\dagger\) produces
                either a set of states satisfying \(Ïˆ\), or the empty
                set. </p>
            </razzle-slide>
            <razzle-slide>
                <p> \(âŸ¨Ï†âŸ©CâŸ¨p\oplus
                âŠ¤âŸ©\) expresses under-approximation.</p><p> holds just in
                case every set of states satisfying \(Ï†\)
                contains some member that \(âŸ¦CâŸ§\) sends to
                a state contained in \(v(p)\).</p>
            </razzle-slide>
            <razzle-slide>We also build a command language, but we'll skip that</razzle-slide>
            <razzle-slide>
                <p>We get a lot of expressive power.</p>
                <ol>
                    <li>Hoare Triples: \(\{p\}C\{q\}\) iff \(âŸ¨pâŸ©CâŸ¨qâˆ¨âŠ¤^\oplusâŸ©\)</li>
                    <li>Heisenbugs: \(âŸ¨Ï†âŸ©CâŸ¨\mathsf{err}\oplus âŠ¤âŸ©\)</li>
                    <li>Fair Shuffle: \(âŸ¨Ï†âŸ©CâŸ¨p\oplus q\oplus r â€¦âŸ©\)</li>
                </ol>
                <p>Given a concrete \(Î£\), concrete command language generating 
                \(C\), and concrete atoms \(p\), you can
                equip OL with a sound proof system to reason about the above.
                </p>
                <p>
                A complete proof system for an interesting command language is
                impossible, because OL (like HL) can express nontermination.
                </p>
            </razzle-slide>
            <razzle-slide>
                <p>Corollary to big theorem: </p>
                <p><em>Nondeterministic OL can falsify HL triples</em></p>
                <p>we have \(\nvDash\{p\}C\{q\}\) just in case for some \(Ï†â‡’p\) where \(Ï†\) is satisfiable, \(âŸ¨Ï†âŸ©CâŸ¨\bar{q}\oplus âŠ¤âŸ©\)</p>
                <p>Or anyway, this holds if \(C\) is guaranteed to terminate.</p>

            </razzle-slide>
            <razzle-slide>
                <h3>Generalizing</h3>
                <p> What is \(âŸ¦CâŸ§^\dagger\)?</p>
                <p> Intuitively, \(âŸ¦CâŸ§ : Î£ â†’ ğ’«(Î£)\)</p>
                <p> But, \(âŸ¦CâŸ§^\dagger : ğ’«(Î£) â†’ ğ’«(Î£)\)</p>
                <p> So you do the obvious thing:</p>
                <p>\(âŸ¦CâŸ§^\dagger(X) := \bigcup\{âŸ¦CâŸ§(x) | x âˆˆ X\}\)</p>
                <p>which is really a completely general construction:</p>
                <p>\(\mathsf{bind}:ğ’«(A)â†’(Aâ†’ğ’«(B))â†’ğ’«(B)\)</p>
            </razzle-slide>
            <razzle-slide>
                <p>It turns out that this \(\mathsf{bind}\), along with the singleton constructor for \(\mathsf{unit}:Aâ†’ğ’«(A)\), make \(ğ’«\) a monad.</p>
                <p>It also has a little bit of extra structure: \(âˆª\) and \(\varnothing\) make \(ğ’«(X)\) a commutative monoid, for any \(X\).</p>
            </razzle-slide>
            <razzle-slide>
                <p>So, callback to earlier:</p>
                <p>An execution model is a triple \(âŸ¨M,â¬¦,\mathbf{1}âŸ©\), where \(M\) is a Monad, and \(â¬¦,\mathbf{1}\) are the multiplication and unit providing a (partial, commutative) monoid structure on every \(M(X)\)
                </p>
            </razzle-slide>
            <razzle-slide>
                <p>Outcome logic can be made parametric on a choice of monad, \(M\), monoid structure on each \(M(X)\), and clause for \(âŠ¨p\)</p>
                <p>The cash value of that fact is that:
                <ol>
                    <li>You get a principled way of generalizing the semantics
                        to other monads where you can find a reasonable monoid
                        structure.<br>
                        (paper example: probabilisitic programming).
                    </li>
                    <li>You get a principled way of <em>composing</em>
                        semantics, since you can often layer different monads
                        together to generate new monads.<br>
                        (paper example: â€œOutcome-based separation logicâ€).
                    </li>
                </ol>
            </razzle-slide>
            <razzle-slide>
                <p>For example, given error states \(E\), the error
                monad is given by \(\mathsf{Er}_E(X) = E+X\), with
                \(\mathsf{bind}_E\) propagating error states, and \(\mathsf{unit}_E\) just the right-hand inclusion.
                </p>
                <p>\(\mathsf{Er}_E\) has the following nice property: there's a uniform way to
                give \(M \circ \mathsf{Er}_E\) a monad structure, for
                any monad \(M\).
                </p>
            </razzle-slide>
            <razzle-slide>
                <p>
                So, if \(âŸ¨M,â¬¦,\mathbf{1}âŸ©\) is an execution model, so is \(âŸ¨M\circ \mathsf{Er}_E,â¬¦,\mathbf{1}âŸ©\). 
                </p><p>In particular, we get an execution model for non-determinism with errors, which the authors use for non-deterministic separation logic.
                <p>
            </razzle-slide>
        </razzle-deck>
    </body>
    <script defer>
            document.body.style.setProperty('--razzle-hide',1)
    </script>

</html>
